//中序遍历（非递归）
//顺序:左根右
/*
思路：
①一直往左走到尽头，入栈。若左孩子为空，出栈一个结点（访问）
②若刚出栈的右孩子存在，①一直往左走到尽头，入栈。若左孩子为空，出栈一个结点（访问）
③若刚出站的右孩子不存在，继续出栈
*/

（入栈顺序：右孩子先入栈，左孩子再入栈）
//BTNode *bt其中bt指的是二叉树的指针(首先从根节点开始进入)
void 中序遍历(BTNode *bt)
{
	if(bt!=NULL)					//根节点不为0则继续（不是空树）
	{
		BTNode *Stack[maxSize];		//建立一个栈用来存储遍历的数字以及是否出栈
		int top=-1;					//初始化
		BTNode *p=NULL;				//*p遍历指针跟随bt指针
		p=bt;						//根节点入p遍历指针
		while(top!=-1||p!=NULL)		//栈不为空，p遍历指针不为空
		{
			while(p!=NULL)			//p遍历指针不为空（在p遍历指针的辅助下左孩子全部入栈）
			{
				Stack[++top]=p;		//p遍历指针放在栈内
				p=p->lchild;		//一直查看左孩子直到尽头
			}
			if(top!=-1)				//如果栈不为空
			{
				p=Stack[top--];		//出栈一个入p遍历指针（因为左孩子走到尽头需要出栈一个结点）(栈-1)
				visit(p);
				p=p->rchild;		//查看右孩子状态（如果右孩子->还有左孩子结点重复入栈操作）
			}
		}
	}
}
