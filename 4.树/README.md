# 树  
> //2019.11.18  
### 基本概念  
![树-用来解释基本概念](/4.树/png/树-用来解释基本概念.png)  
- `结点`：A1、A2、A3、A4、A5、A6、A7都是结点  
![树-用来解释基本概念-结点的度](/4.树/png/树-用来解释基本概念-结点的度.png)  
- `结点的度`:A1的度为3  
![树-用来解释基本概念-树的度](/4.树/png/树-用来解释基本概念-树的度.png)  
- `树的度`:结点的度的最大值  
- `树的高度(深度)`:共有多少层  
![树-树-用来解释基本概念-叶子结点](/4.树/png/树-用来解释基本概念-叶子结点.png)  
- `叶子结点`：A3、A4、A5、A6、A7都是叶子结点  
![树-用来解释基本概念-双亲和孩子](/4.树/png/树-用来解释基本概念-双亲和孩子.png)  
- 双亲  
- 孩子  
### 二叉树  
- 二叉树的约束条件  
![二叉树](/4.树/png/二叉树.png)  
- 二叉树可能的形态  
![二叉树可能的形态](/4.树/png/二叉树可能的形态.png)  
- 满二叉树  
![满二叉树](/4.树/png/满二叉树.png)  
- 完全二叉树  
![完全二叉树](/4.树/png/完全二叉树.png)  
完全二叉树:从最低层开始，从`从右往左`删除结点  
##### 求完全二叉树高度  
`公式：h=log2n」+1（向下取整）`  
`公式：「h=log2(n+1)（向上取整）`  
##### 二叉树的性质  
- 总分支数=总结点数-1  
- 叶子结点数=双分支数+1  
### 二叉树的存储结构  
- 顺序存储结构  
父节点位置:i  
左孩子结点位置:2i+1  
右孩子结点位置:2i+2  
- 链式存储结构  
- 数的孩子兄弟存储结构  
![数的孩子兄弟存储结构](/4.树/png/数的孩子兄弟存储结构.png)  
### 树与二叉树的互相转换  
![数与二叉树的互相转换-数转二叉树](/4.树/png/数与二叉树的互相转换-数转二叉树.png)  
![数与二叉树的互相转换-二叉树转树](/4.树/png/数与二叉树的互相转换-二叉树转树.png)  
### 森林与二叉树的互相转换  
![森林与二叉树的互相转换-二叉树转森林](/4.树/png/森林与二叉树的互相转换-二叉树转森林.png)  
![森林与二叉树的互相转换-森林转二叉树](/4.树/png/森林与二叉树的互相转换-森林转二叉树.png)  
### 遍历（二叉树） 
- 广度优先遍历（层次遍历）  
①从上至下  
②从左至右  
- 深度优先遍历（先序中序后序）  
### 遍历（树）  
- 广度优先遍历（层次遍历）
①从上至下  
②从左至右  
- 深度优先遍历（先序中序后序）  
`数——>二叉树`  
数的先序：二叉树的先序  
数的后序：二叉树的中序  
### 遍历（森林）
- 广度优先遍历（层次遍历）
①从上至下  
②从左至右  
- 深度优先遍历（先序中序后序）  
`森林——>二叉树`  
森林的先序：二叉树的先序  
森林的后序：二叉树的中序  
### 遍历（代码部分）
- 二叉树的遍历代码（广度）  
①从上至下  
②从左至右  
- 二叉树的遍历代码（深度）  
- 二叉树的非递归代码  
- -先序遍历非递归化代码  
- -后序遍历非递归化代码  
- -中序遍历非递归化代码  
### 中序线索二叉树  
- 存储结构  
- 中序线索二叉树代码  
![中序线索二叉树存储结构](/4.树/png/中序线索二叉树存储结构.png)  
- 前序线索二叉树代码  
- 后序线索二叉树代码  
![后序线索二叉树](/4.树/png/后序线索二叉树.png)  
- 总结  
![前序中序后序线索二叉树](/4.树/png/前序中序后序线索二叉树.png)  
### 哈夫曼树  
- 编码规则  
![哈夫曼树-编码规则](/4.树/png/哈夫曼树-编码规则.png)  
- 解码规则  
从左往右扫描，根据图像进行判断  
0->A  
110->B  
- 路径:指从树中一个结点到另一个结点的分支构成的路线`黄色部分`  
![哈夫曼树-路径](/4.树/png/哈夫曼树-路径.png)  
- 路径长度:指路径上的分支数目(上图 路径长度：3)  
- 树的路径长度:指从根节点到每个结点的路径长度之和  
- 带权路径长度:结点具有权值(结点出现次数)`带权路径长度=从该结点到根节点之间的路径长度×结点的权值`  
![哈夫曼树-带权路径长度](/4.树/png/哈夫曼树-带权路径长度.png)  
- 树的带权路径长度:树中所有叶子结点的带权路径长度之和(WPL)  
![哈夫曼树-树的带权路径长度(WPL)](/4.树/png/哈夫曼树-树的带权路径长度(WPL).png)  
- 哈夫曼二叉树的特点  
- - 权值越大的结点,距离根节点越近  
- - 树中没有度为1的结点。这类树叫正则(严格)二叉树  
- - 树的带权路径长度最短  
![哈夫曼二叉树的特点](/4.树/png/哈夫曼二叉树的特点.png)  
### 哈夫曼树n叉树  
![哈夫曼n叉树](/4.树/png/哈夫曼n叉树.png)  
### 根据遍历序列确定二叉树  
- 先序+中序->二叉树  
![先序加中序构成二叉树](/4.树/png/先序加中序构成二叉树.png)  
- 先序+中序->二叉树(代码)  
### 根据遍历序列估计二叉树  
![根据遍历序列估计二叉树](/4.树/png/根据遍历序列估计二叉树.png)  
- 相同
- 前序遍历和后序遍历结果相同：`只有根节点/空树`  
![前序遍历和后序遍历结果相同](/4.树/png/前序遍历和后序遍历结果相同.png)  
- 前序遍历和中序遍历结果相同：`只有右子树`  
![前序遍历和中序遍历结果相同](/4.树/png/前序遍历和中序遍历结果相同.png)  
![前序遍历和中序遍历结果相同-具体例子](/4.树/png/前序遍历和中序遍历结果相同-具体例子.png)  
- 中序遍历和后序遍历结果相同：`只有左子树`  
![中序遍历和后序遍历结果相同-具体例子](/4.树/png/中序遍历和后序遍历结果相同-具体例子.png)  

- 相反
- 前序遍历和后序遍历结果相反：`只有左子树/右子树`  
![前序遍历和后序遍历结果相反-具体例子](/4.树/png/前序遍历和后序遍历结果相反-具体例子.png)  
- 前序遍历和中序遍历结果相反：`只有左子树`  
![前序遍历和中序遍历结果相反-具体例子](/4.树/png/前序遍历和中序遍历结果相反-具体例子.png)  
- 中序遍历和后序遍历结果相反：`只有右子树`  
![中序遍历和后序遍历结果相反-具体例子](/4.树/png/中序遍历和后序遍历结果相反-具体例子.png)  
### 用二叉树来存储算术表达式  
- 手工建树  
![用二叉树来存储表达式-手工建树](/4.树/png/用二叉树来存储表达式-手工建树.png)  
- 用栈建树  
①建立两个栈：一个用来存储数字，另一个用来存储运算符  
②从左往右依次扫描  
③如果扫描到的运算符大于栈内运算符->入栈  
如果扫描到的运算符小于等于栈内运算符->出栈(中缀表达式)  
④出栈：(扫描到的运算符小于等于栈内运算符)出栈。  
存储数字的栈中：栈顶为右孩子(出栈)  
存储数字的栈中：栈顶-1为左孩子(出栈)  
存储运算符的栈中：栈顶运算符出栈成为根节点(连线)  
★根节点再次入操作数栈内  
⑤从左往右扫描表达式  
![用栈建树结果](/4.树/png/用栈建树结果.png)  
- 用栈建树(代码)  
类似于`表达式求值`  
---
:bookmark:By:zxg  
