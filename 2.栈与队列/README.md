# 栈  
> //2019.11.13  
### 基本概念  
- `栈`:是一种只能在一端进行插入或删除的线性表  
- `逻辑结构`:先进后出[FILO]  
- `存储结构`①顺序栈②链栈  
### 顺序栈  
- 初始化操作  
```c
int stack[maxSize];
int top=-1;
```
- 入栈操作
```c
stack[++top]=1;   //先自增，再取值
stack[++top]=2;   //先自增，再取值
```
- 出栈操作
```c
x=stack[top--];   //先取值，再自减
x=stack[top--];   //先取值，再自减
```
- 再次入栈操作（直接覆盖掉已经出栈的位置）  
- 栈满状态：
```c
top==maxSize-1  //为真，不能在进栈
```
- 栈空状态：
```c
top==-1  //为真，不能在出栈
```
### 链栈（带头结点的单链表）  
- 初始化操作 
```c
LNode *head=(LNode*)malloc(sizeof(LNode));
head->next=NULL;
LNode *top=NULL;
```
- 入栈操作  
- 出栈操作  
- 栈满状态：无栈满状态
- 栈空状态：
```c
head->next==NULL  //为真，栈空
```
# 队列  
> //2019.11.14  
### 基本概念  
- `队列`:是一种只能在一端插入元素（队头），在另一端进行删除元素（队尾）  
- `逻辑结构`:先进先出[FIFO]  
- `存储结构`①顺序队②链队  
### 顺序队  
- 初始化操作  
```c
int queue[maxSize];
int front=0;
int rear=0;
```
- 入队操作  
- 出队操作  
- 队空状态：
```c
rear==front  //不一定
```
- 为解决假溢出现象
```c
//入队
rear=(rear+1)%maxSize;
queue[rear]=x;

//出队
front=(front+1)%maxSize;
x=queue[front];

```
### 链队（带头结点的单链表）  
- 初始化操作  
```c
typedef struct
{
  LNode *front;
  LNode *rear;
}queue;
```
- 入栈操作  
- 出栈操作  
- 栈满状态：无栈满状态
- 栈空状态：
```c
head->next==NULL  //为真，栈空
```
### 栈的输出序列  
- 由出栈序列判断容量  
### 表达式的转化  
- 中缀表达式——>前缀表达式  
- 中缀表达式——>后缀表达式  
- 后缀表达式——>中缀表达式  
- 后缀表达式——>前缀表达式  
### 应用问题
- 用栈实现表达式转换  
1.  中缀表达式——>后缀表达式（入栈元素`小于等于`栈内元素，栈内元素出栈，入栈元素入栈）  
（指针循环方向：从左——>右）  
2.  中缀表达式——>前缀表达式（入栈元素`小于`栈内元素，栈内元素出栈，入栈元素入栈）  
（指针循环方向：从右——>左）  
3.  后缀表达式——>前缀表达式  
### 用栈实现表达式的求值  
- 中缀表达式求值  
- 后缀表达式求值  
- 前缀表达式求值  
### 配置问题  
- 正常配置  
- 非正常配置  
### 队列的扩展  
- 双端队列  
1.  输入受限  
2.  输出受限  
3.  输入受限&输出受限  
### 栈的扩展  
- 共享栈（两个栈共享一个存储空间）  
1.  共享栈初始化  
![共享栈初始化](/2.栈与队列/png/共享栈初始化.png)  
2.  共享栈栈满  
![共享栈栈满](/2.栈与队列/png/共享栈栈满.png)  
```c
top[0]==-1;       //为真则s1为空
top[1]==-maxSize; //为真则s2为空
top[0]+1==top[1]  //为真则栈满
```
- 括号匹配代码  
- 用栈来模拟队列  
- 括号匹配  
### 卡特兰数
n个数按照某种顺序入栈，并且可在任意时刻出栈，不同出栈序列为：  
Cn=(2n)!/(n+1)!n!  
#### 例如:1、2、3有多少个不同的出栈序列  
Cn=6!/(3+1)!3!=5种  
---
:bookmark:By:zxg  
